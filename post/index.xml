<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Phantom</title>
    <link>https://phantommmm.github.io/post/</link>
    <description>Recent content in Posts on Phantom</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Phantom</copyright>
    <lastBuildDate>Sat, 18 Jul 2020 13:39:23 +0800</lastBuildDate>
    
	<atom:link href="https://phantommmm.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Netty中的Reactor模型</title>
      <link>https://phantommmm.github.io/post/netty%E4%B8%AD%E7%9A%84-reactor%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sat, 18 Jul 2020 13:39:23 +0800</pubDate>
      
      <guid>https://phantommmm.github.io/post/netty%E4%B8%AD%E7%9A%84-reactor%E6%A8%A1%E5%9E%8B/</guid>
      <description>Netty中的Reactor模型 前面文章介绍了三种 Reactor 的线程模型, 那么它们和 NioEventLoopGroup 又有什么关系呢? 其实, 不同的设置 NioEventLoopGroup 的方式就对应了不同的 Reactor 的线程模</description>
    </item>
    
    <item>
      <title>Java假泛型</title>
      <link>https://phantommmm.github.io/post/java%E5%81%87%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Thu, 16 Jul 2020 13:39:23 +0800</pubDate>
      
      <guid>https://phantommmm.github.io/post/java%E5%81%87%E6%B3%9B%E5%9E%8B/</guid>
      <description>Java泛型 Java的泛型是JDK5带来的新特性，其本质是参数化类型，也就是说所操作的数据类型被指定为一个参数（type parameter）</description>
    </item>
    
    <item>
      <title>深拷贝与浅拷贝</title>
      <link>https://phantommmm.github.io/post/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</link>
      <pubDate>Thu, 16 Jul 2020 13:39:23 +0800</pubDate>
      
      <guid>https://phantommmm.github.io/post/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</guid>
      <description>深拷贝与浅拷贝 创建对象的五种方式 ​ ①、通过 new 关键字 这是最常用的一种方式，通过 new 关键字调用类的有参或无参构造方法来创建对象。比如 Object obj = new Object(); ②、</description>
    </item>
    
    <item>
      <title>Redis LUA</title>
      <link>https://phantommmm.github.io/post/redis-lua/</link>
      <pubDate>Wed, 15 Jul 2020 13:39:23 +0800</pubDate>
      
      <guid>https://phantommmm.github.io/post/redis-lua/</guid>
      <description>Redis LUA 背景 简单的需求如下 公司运营为了提高用户活跃而设计了一个积分策略，规定用户只要在指定时间段内上线打卡就有机会获得积分，积分可以换取礼物。每</description>
    </item>
    
    <item>
      <title>TCP协议（下）</title>
      <link>https://phantommmm.github.io/post/tcp%E5%8D%8F%E8%AE%AE%E4%B8%8B/</link>
      <pubDate>Thu, 09 Jul 2020 13:39:23 +0800</pubDate>
      
      <guid>https://phantommmm.github.io/post/tcp%E5%8D%8F%E8%AE%AE%E4%B8%8B/</guid>
      <description>TCP协议（下） RST RST用于异常的关闭连接，发送RST包关闭连接时，不必等待缓冲区的包都发出去（例如FIN），直接丢弃缓存区的包发送RST包</description>
    </item>
    
    <item>
      <title>QUIC协议</title>
      <link>https://phantommmm.github.io/post/quic%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Wed, 08 Jul 2020 13:39:23 +0800</pubDate>
      
      <guid>https://phantommmm.github.io/post/quic%E5%8D%8F%E8%AE%AE/</guid>
      <description>QUIC协议 QUIC （Quick UDP Internet Connections）协议是一个由 Google 推出的一款基于 UDP 实现的高效、可靠的网络协议，它基于 UDP 实现了一系列可靠的机</description>
    </item>
    
    <item>
      <title>TCP协议（上）</title>
      <link>https://phantommmm.github.io/post/tcp%E5%8D%8F%E8%AE%AE%E4%B8%8A/</link>
      <pubDate>Wed, 08 Jul 2020 13:39:23 +0800</pubDate>
      
      <guid>https://phantommmm.github.io/post/tcp%E5%8D%8F%E8%AE%AE%E4%B8%8A/</guid>
      <description>TCP协议（上） TCP 在 IP 协议不可靠（尽力而为也就是无服务）之上建立了可靠的全双工字节流数据传输服务。首先，它是基于字节流的，也就是说它是以字节</description>
    </item>
    
    <item>
      <title>UDP协议</title>
      <link>https://phantommmm.github.io/post/udp%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Sat, 04 Jul 2020 13:39:23 +0800</pubDate>
      
      <guid>https://phantommmm.github.io/post/udp%E5%8D%8F%E8%AE%AE/</guid>
      <description>UDP协议 UDP 协议相对于 TCP 来说就没有那么多复杂的功能了，它只在 IP 协议提供的不可靠服务的基础上增加了一些基本的功能。 报文格式 我们先来看看它的报文</description>
    </item>
    
    <item>
      <title>设计模式-责任链</title>
      <link>https://phantommmm.github.io/post/%E8%B4%A3%E4%BB%BB%E9%93%BE/</link>
      <pubDate>Fri, 03 Jul 2020 13:39:23 +0800</pubDate>
      
      <guid>https://phantommmm.github.io/post/%E8%B4%A3%E4%BB%BB%E9%93%BE/</guid>
      <description>开发中的设计模式&amp;ndash;责任链 背景 开发项目中涉及到当用户接入客服系统时，会按顺序依次经过留言、建立连接、插队、排队的处理器进行处理判断</description>
    </item>
    
    <item>
      <title>设计模式-适配器</title>
      <link>https://phantommmm.github.io/post/%E9%80%82%E9%85%8D%E5%99%A8/</link>
      <pubDate>Wed, 01 Jul 2020 13:39:23 +0800</pubDate>
      
      <guid>https://phantommmm.github.io/post/%E9%80%82%E9%85%8D%E5%99%A8/</guid>
      <description>开发中的设计模式&amp;ndash;适配器 背景 开发中如果我们要用到接口的话，我们需要实现接口，我们需要实现接口中的所有方法，但是在有些场景，一个接</description>
    </item>
    
    <item>
      <title>Redis高级数据结构</title>
      <link>https://phantommmm.github.io/post/redis%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sat, 27 Jun 2020 13:39:23 +0800</pubDate>
      
      <guid>https://phantommmm.github.io/post/redis%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>Redis高级数据结构 平常我们接触最多的是5个入门级数据结构：String，Hash，List，Set，Sorted Set。本文介绍3个高级</description>
    </item>
    
    <item>
      <title>SpringBoot-Starter</title>
      <link>https://phantommmm.github.io/post/springbootstarter/</link>
      <pubDate>Thu, 25 Jun 2020 13:39:23 +0800</pubDate>
      
      <guid>https://phantommmm.github.io/post/springbootstarter/</guid>
      <description>SpringBoot-Starter springboot相较于spring的一大优点就是提供给我们开箱即用的一些组件，例如spring-starter依赖。它内部引入相关组件</description>
    </item>
    
    <item>
      <title>静态分派与动态分派</title>
      <link>https://phantommmm.github.io/post/%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E4%B8%8E%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE/</link>
      <pubDate>Sat, 20 Jun 2020 13:39:23 +0800</pubDate>
      
      <guid>https://phantommmm.github.io/post/%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E4%B8%8E%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE/</guid>
      <description>静态分派与动态分派 背景 Java 的动态分派和静态分派也是 Java 方法的执行原理。 Java 源代码的编译之后，方法之间的调用是使用符号引用来表示的。当字节码被 JVM 加载</description>
    </item>
    
    <item>
      <title>Reactor模式</title>
      <link>https://phantommmm.github.io/post/reactor%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 15 Jun 2020 13:39:23 +0800</pubDate>
      
      <guid>https://phantommmm.github.io/post/reactor%E6%A8%A1%E5%BC%8F/</guid>
      <description>Reactor模式 Reactor模式也叫反应器模式，大多数IO相关组件如Netty、Redis在使用的IO模式，为什么需要这种模式，它是如何</description>
    </item>
    
    <item>
      <title>负载均衡算法</title>
      <link>https://phantommmm.github.io/post/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 13 Jun 2020 13:39:23 +0800</pubDate>
      
      <guid>https://phantommmm.github.io/post/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95/</guid>
      <description>负载均衡算法 负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高</description>
    </item>
    
    <item>
      <title>Redis是单线程？</title>
      <link>https://phantommmm.github.io/post/redis6.0/</link>
      <pubDate>Sat, 06 Jun 2020 13:39:23 +0800</pubDate>
      
      <guid>https://phantommmm.github.io/post/redis6.0/</guid>
      <description>Redis是单线程？ Redis 6.0之前 单线程 如何理解Redis单线程？ 单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程</description>
    </item>
    
    <item>
      <title>HTTP</title>
      <link>https://phantommmm.github.io/post/http/</link>
      <pubDate>Thu, 20 Feb 2020 13:39:23 +0800</pubDate>
      
      <guid>https://phantommmm.github.io/post/http/</guid>
      <description>网络 HTTP HTTP是一种不保存状态的协议，即协议对于发送过的请求和接受的响应都不做持久化的处理 HTTP是 明文协议。每个HTTP请求和返回的每个b</description>
    </item>
    
    <item>
      <title>TCP-IP</title>
      <link>https://phantommmm.github.io/post/tcp-ip/</link>
      <pubDate>Wed, 19 Feb 2020 13:39:23 +0800</pubDate>
      
      <guid>https://phantommmm.github.io/post/tcp-ip/</guid>
      <description>TCP首部格式 三次握手过程中的报文是不含数据的，只包含tcp协议首部。 序号： seq 占4字节。序号范围是 0 到 2的32次方-1 ，序号增加到 2的32次</description>
    </item>
    
    <item>
      <title>IO模型</title>
      <link>https://phantommmm.github.io/post/io%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sun, 16 Feb 2020 13:39:23 +0800</pubDate>
      
      <guid>https://phantommmm.github.io/post/io%E6%A8%A1%E5%9E%8B/</guid>
      <description>五种主要的IO模型 同步阻塞IO （Blocking IO） （1）当用户线程调用了read系统调用，内核就开始了IO的第一个阶段：准备数据（即系统</description>
    </item>
    
    <item>
      <title>进程与线程</title>
      <link>https://phantommmm.github.io/post/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Sat, 15 Feb 2020 13:39:23 +0800</pubDate>
      
      <guid>https://phantommmm.github.io/post/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid>
      <description>进程和线程 基本概念 串行 多个任务执行，一个执行完再执行另外一个。 并发(concurrency) 多个线程在单个核心运行，同一时间一个线程运行，系</description>
    </item>
    
  </channel>
</rss>